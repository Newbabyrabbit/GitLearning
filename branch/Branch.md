# 分支  
分支实际上是一个指向当前‘提交对象’的指针。  
一个项目默认只有一个分支，即 master 分支。  
HEAD指针指向当前分支，在一个项目不断提交的过程中，HEAD指针在不断右移。  
`git branch` 查看所有分支，*标志的是当前分支。  
`git branch a-branch` 在当前提交对象上创建一个分支。  
`git checkout a-branch` 切换当前分支   
**解决问题分支**
当开发过程中发现了一个问题需要去解决时，可以提交或存储当前工作区或存储区的内容，再在当前分支创建例如issue53的分支，去做一些问题解决。当问题解决后，`git checkout master` 切换为master分支，再合并master和issue53分支（`git merge issue53`），因为issue53是产生于master分支所指向的快照，所以合并的时候仅仅将master分支右移即可（Fast-Forward 快进合并）。git会根据合并的内容创建一次新的提交，快进合并的话并不会产生一次新的提交，所以就看不到了合并历史记录。若想查看合并历史记录，就必须强制产生一次新的提交，使用`--no-ff` 即可，`git merge --no-ff a-branch`。    
**修复BUG分支**
若issue53 分支还未修改完毕，此时又要去修复bug，则应该提交或储存当前分支修改，切换回master分支，在生成一个bug修复分支并切换。`git checkout -b hotfix` 创建并切换为该分支，进行一些bug修复。当修复完成且issue53已解决，则应该合并这两个分支。此时分支合并可能会发生冲突，因为issue53和hotfix可能修改了相同的文件的相同位置的内容。合并的时候Git会生成一个合并后的提交对象，如果发生了冲突，那么这个新的提交对象并不会提交，而是等着开发者去解决冲突，然后由开发者提交。当bug修复完成时，hotfix分支可能没用了，就可以删掉。`git branch -d hotfix`   
**合并的时候发生了什么？**  
当合并两个分支时，Git会自动去寻找这两个分支的共同父级，即分岔点。然后将分岔点处的快照与这两个分支的快照进行比较，找出修改的部分，创建一个新的提交（若没有发生冲突时）。    
**发生冲突**  
当发生冲突时，往往是由对同一行代码或者同一个模块做出修改造成的。此时Git就无法完成自动合并（当然，无冲突的部分自动合并，有冲突的部分手动解决冲突，自己提交）
**冲突的类型**  
1. 编辑冲突：对同一行代码做了不同的修改（会在冲突文件中留下冲突标记）
2. 内容冲突：对代码中的几个部分做出各自的修改，例如：两人修改了同一个函数   
当你在合并的时候犯了错误或解决冲突时出了错，则应该果断的放弃合并，这样也不会在工作区中留下合并的痕迹 `git reset --merge`
